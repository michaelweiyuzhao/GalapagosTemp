<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>fnet: A Low Level Protocol for Intra-Rack Communication</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body>
        <h1 id="fnet-A-Low-Level-Protocol-for-Intra-Rack-Communication">fnet: A Low Level Protocol for Intra-Rack Communication</h1>
<h2 id="1-Introduction">1. Introduction</h2>
<p>fnet (subject to change) is a low level protocol with flow control and error checking without the overhead of Ethernet.</p>
<hr>
<h2 id="2-Specification">2. Specification</h2>
<p>This protocol builds on sections of the 64b66b encoding PCS and MII detailed in IEEE 802.3 Clause 49 with the added benefit of source and destination signalling, and flow control capabilities within a lower level protocol. This protocol was originally designed to facilitate communication between up to 48 transceivers connected through an Arista 7130 layer one switch.</p>
<h3 id="21-Terms-and-Definitions">2.1 Terms and Definitions</h3>
<p>Payload: 8 bytes of user and control bytes.</p>
<p>Header <em>or</em> Sync Header: 2 bit synchronization header.</p>
<p>Transfer: A single 8 byte payload and 2 bit header of a packet.</p>
<p>Packet: Multiple 8 byte payloads and 2 bit headers belonging together.</p>
<h3 id="22-Encoding-Structure">2.2 Encoding Structure</h3>
<p>The encoding structure shall have the format shown in Figure 0. The transmitter must send packets in this format and the receiver must receive packets encoded in this format.</p>
<p>Legend:</p>
<p>User Bytes:</p>
<ul>
<li>D<sub>0</sub>-D<sub>7</sub> = Data bytes</li>
<li>Src = Source byte</li>
<li>Dst = Destination byte</li>
</ul>
<p>Control Bytes:</p>
<ul>
<li>T = Type byte</li>
<li>C = CRC8 byte</li>
<li>I = Idle byte = <code>0x00</code></li>
<li>X = Don't care</li>
</ul>
<p><img src="file:images/Figure_0.png" alt="Figure 0"></p>
<p>Figure 0. Encoding Scheme</p>
<p>Rules:</p>
<ol>
<li>Packet transfers must be one of the above formats.</li>
<li>Packets must start with a transfer of type T_S1, T_S2, T_S3, T_S4 or T_S5.</li>
<li>Packets must end with a transfer of type T_T0, T_T1, T_T2, T_T3, T_T4, T_T5 or T_T6.</li>
<li>Transfer formats must be chosen to include as many Data bytes as possible per transfer.</li>
<li>Packets must include one and only one CRC8 byte.</li>
<li>Idle (T_IDLE), Pause (T_PAUSE) and Error (T_ERROR) transfers can appear at any time.</li>
<li>CRC8 byte is generated as per <a href="####2.2.1-crc8-insertion-and-checking">Section 2.2.1.</a>.</li>
<li>Dst = 0x00 broadcasts and sends the packet to all receivers.</li>
<li>Src = 0x00 is undefined.</li>
<li>A transceiver may send packets to itself (Dst = Src), for example for testing purposes, but this behaviour is undefined.</li>
</ol>
<h4 id="221-CRC8-Insertion-and-Checking">2.2.1 CRC8 Insertion and Checking</h4>
<p>CRC8 parity bits are generated using the following polynomial.</p>
<p>C(x) = 1 + x + x<sup>5</sup> +x<sup>6</sup> + x<sup>8</sup></p>
<p>The CRC8 generated shall produce the same result as the implementation shown in Figure 1. In Figure 1 the 8 delay elements S0, ..., S7, shall be initialized to zero at the start of each received packet. After this all User bytes of the packet are used serially (in transmission order) to compute the CRC8. The generated CRC8 bits shall be placed in its designated CRC8 byte by the transmitter. The receiver shall use the generated CRC8 byte to verify the correctness of the packet and set the Type byte of the last transfer to T_ERROR when the CRC8 does not match.</p>
<p><img src="file:images/Figure_1.png" alt="Figure 1"></p>
<p>Figure 1. CRC8 Generator</p>
<h3 id="23-Scrambling">2.3 Scrambling</h3>
<p>All transfers are scrambled by the transmitter and descrambled by the receiver with self-synchronizing scramblers and descramblers. The scrambler and descrambler shall implement the following polynomial.</p>
<p>G(x) = 1 + x<sup>39</sup> + x<sup>58</sup></p>
<p>The scrambler shall produce the same result as the implementation shown in Figure 2 and the descrambler shall produce the same result as the implementation shown in Figure 3. The value for the initial state of the scrambler and descrambler should be alternating <code>0</code>'s and <code>1</code>'s starting with either bit. The scrambler and descrambler are run continuously on all payload bits. The header bits bypass the scrambler and descrambler.</p>
<p><img src="file:images/Figure_2.png" alt="Figure 2"></p>
<p>Figure 2. Scrambler</p>
<p><img src="file:images/Figure_3.png" alt="Figure 3"></p>
<p>Figure 3. Descrambler</p>
<h3 id="24-Receiver-Data-Alignment">2.4 Receiver Data Alignment</h3>
<p>Data alignment is achieved by the receiver using the synchronization header. Valid header values <code>01</code> and <code>10</code> allow invalid alignments to be identified and corrected. Lock is obtained as specified in the block lock state machine shown in Figure 4. All transfers are invalid until alignment is achieved.</p>
<p>Symbols:</p>
<ul>
<li>reset: reset signal</li>
<li>block_lock: alignment achieved signal</li>
<li>sh_cnt: sync headers seen counter</li>
<li>sh_invalid_cnt: invalid sync headers seen counter</li>
<li>sh_valid: current sync header is valid</li>
<li>SLIP: slip signal to transition to next alignment</li>
<li>UCT: unconditional transition</li>
</ul>
<p><img src="file:images/Figure_4.png" alt="Figure 4"></p>
<p>Figure 4. Synchronization Block State Machine</p>
<h3 id="25-Flow-control">2.5 Flow control</h3>
<p>Flow control shall be achieved with the use of Pause (T_PAUSE) packets. An overwhelmed receiver shall signal for the transmitter to send a Pause packet (D<sub>0</sub>-D<sub>3</sub> != <code>0x00000000</code>) to Dst = <code>0x00</code> (broadcast). Once the receiver recovers it shall signal for the transmitter to send an Unpause packet (D<sub>0</sub>-D<sub>3</sub> = <code>0x00000000</code>) to Dst = <code>0x00</code> (broadcast). Receivers that receive the Pause packet should stop sending packets to the receiver with address Src until an Unpause packet is received with address Src. A receiver receiving Pause and Unpause packets with Src equal to its own is undefined behaviour.</p>
<hr>
<h2 id="3-Example-Implementation">3. Example Implementation</h2>
<p>An example implementation with modified AXI4-Stream as the user interface. This implementation assumes transceivers are not shared between multiple processes with different Src Addresses. A high level block diagram is presented in Figure 5.</p>
<p><img src="file:images/Figure_5.png" alt="Figure 5"></p>
<p>Figure 5. High Level Block Diagram</p>
<h3 id="31-TX">3.1 TX</h3>
<h4 id="311-TX-Interface">3.1.1 TX Interface</h4>
<p>The user interface for TX consists of a modified AXI4-Stream interface with 64-bit TDATA, 8-bit TKEEP, 8-bit TUSER, 8-bit TDEST, 1-bit TLAST, 1-bit TVALID and 1-bit TREADY as well as <code>s_pause</code> and <code>s_send_pause</code> for flow control purposes. Clock and reset are provided by the transceiver.</p>
<table>
<thead>
<tr>
<th>Port</th>
<th style="text-align:right">Width</th>
<th style="text-align:center">Direction</th>
<th>Clock</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tx_usrclk2_out</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>User clock from transceiver.</td>
</tr>
<tr>
<td>tx_reset_out</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>Reset from transceiver.</td>
</tr>
<tr>
<td>s_axis_tdata</td>
<td style="text-align:right">[63:0]</td>
<td style="text-align:center">in</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TDATA. Maps to payload data bytes.</td>
</tr>
<tr>
<td>s_axis_tkeep</td>
<td style="text-align:right">[7:0]</td>
<td style="text-align:center">in</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TKEEP. Used to determine payload type.</td>
</tr>
<tr>
<td>s_axis_tuser</td>
<td style="text-align:right">[7:0]</td>
<td style="text-align:center">in</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TUSER. Maps to Src byte. Should be held steady after reset because of the Pause injection implementation.</td>
</tr>
<tr>
<td>s_axis_tdest</td>
<td style="text-align:right">[7:0]</td>
<td style="text-align:center">in</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TDEST. Maps to Dst byte.</td>
</tr>
<tr>
<td>s_axis_tlast</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">in</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TLAST. Used to determine payload type.</td>
</tr>
<tr>
<td>s_axis_tvalid</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">in</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TVALID. Used to signal valid.</td>
</tr>
<tr>
<td>s_axis_tready</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TREADY. Used to signal ready.</td>
</tr>
<tr>
<td>s_pause</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">in</td>
<td>tx_usrclk2</td>
<td>Pauses all transmitter activity when asserted. Can be used to implement pausing. Tie to <code>0</code> if pausing is implemented manually.</td>
</tr>
<tr>
<td>s_send_pause</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">in</td>
<td>tx_usrclk2</td>
<td>Send Pause and Unpause Packets. A Pause packet is generated on the positive edge of <code>s_send_pause</code> and an Unpause packet is generated on the negative edge of <code>s_send_pause</code>. TUSER is used as the Src byte for the Pause and Unpause packets.</td>
</tr>
</tbody>
</table>
<h4 id="312-Encoder">3.1.2 Encoder</h4>
<p>The encoder takes the modified AXI4-Stream interface and generates packets in the format described in <a href="##2.2-encoding-structure">Section 2.2</a>. All user-facing inputs and outputs are buffered. When TREADY goes low, data held in the user buffers are stalled and the one cycle of data that is potentially valid while TREADY propogates through the buffer is clocked into a separate buffer. When TVALID goes high, the user buffer is filled with the data held in the separate buffer before resuming normal operation. The CRC8 byte is not generated by the encoder but a byte of space is set to <code>0x00</code> where the CRC8 will go and the CRC8 insertion block will fill it in with the correct CRC8 byte. The constructed payload and header are then sent to the CRC8 insertion block. The encoder also takes inputs <code>inject_pause_in</code> and <code>pause_in</code>. The signal <code>inject_pause_in</code> is generated from the user <code>s_send_pause</code> and another internal pause signal. The signal <code>pause_in</code> maps directly to <code>s_pause</code>. Asserting <code>pause_in</code> causes the encoder to set TREADY low and continually send Idle transfers until <code>pause_in</code> is deasserted. Asserting <code>inject_pause_in</code> causes the encoder to set TREADY low for one cycle while it sends a single Pause packet with D<sub>0</sub>-D<sub>3</sub> = <code>0xfffffffff</code>. Deasserting <code>inject_pause_in</code> causes the encoder to set TREADY low for one cycle while it sends a single Pause packet with D<sub>0</sub>-D<sub>3</sub> = <code>0x00000000</code>. When both of these signals trigger at the same time, precedence is given to servicing <code>inject_pause_in</code>, and then <code>pause_in</code>.</p>
<h4 id="313-CRC8-Insertion">3.1.3 CRC8 Insertion</h4>
<p>The CRC8 insertion block generates a CRC8 byte in the method described in <a href="###2.2.1-crc8-insertion-and-checking">Section 2.2.1</a>. The CRC8 generation is unimplemented in the current design and passes through all payloads and headers directly to the scrambler. If it were to be implemented, CRC8 generation should be implemented with an 8-bit addressed lookup table which holds precomputed CRC8 results in order to generate a CRC8 byte for up to 64 bits of data per cycle. A description of this technique can be found in <a href="#4.-further-reading">Section 4</a> at the link &quot;CRC32 Byte by Byte&quot;. The internal state of the CRC8 generator should be reset to <code>0x00</code> at the start of every packet and the header and type byte should be used to determine which bytes to run through the CRC8 generator. The resulting CRC8 byte should then be written into the last transfer of the packet in the appropriate location left by the encoder. The completed payload and header should then be sent to the scrambler.</p>
<h4 id="314-Scrambler">3.1.4 Scrambler</h4>
<p>The scrambler scrambles all payload bits in the method described in <a href="###2.3-scrambling">Section 2.3</a>. The scrambler is implemented as a parallel 64-bit combinational scrambler that registers the internal state every cycle. The parallelism is implemented using the Vivado HLS unroll pragma. The header is unchanged. The header and scrambled payload are then sent to the Xilinx GT TX interface and sent through the transceiver.</p>
<h3 id="32-RX">3.2 RX</h3>
<h4 id="321-Block-Synchronizer">3.2.1 Block Synchronizer</h4>
<p>The received header from the Xilinx GT RX interface is used to determine data alignment. The implementation is that of <a href="###2.4-receiver-data-alignment">Section 2.4</a>. The slip signal is sent to the Xilinx GT to transition to the next possible alignment.</p>
<h4 id="322-Descrambler">3.2.2 Descrambler</h4>
<p>The received payload is descrambled in the method describled in <a href="###2.3-scrambling">Section 2.3</a>. The descrambler is implemented as a parallel 64-bit combinational descrambler that registers the internal state every cycle. The parallelism is implemented using the Vivado HLS unroll pragma. The header is unchanged. The header and descrambled payload are then sent to the CRC8 checking block.</p>
<h4 id="323-CRC8-Checking">3.2.3 CRC8 Checking</h4>
<p>The CRC8 checking block generates a CRC8 byte in the method described in <a href="###2.2.1-crc8-insertion-and-checking">Section 2.2.1</a>. The CRC8 checking is unimplemented in the current design and passes through all payloads and headers directly to the payload manager. If it were to be implemented, CRC8 generation should be implemented with an 8-bit addressed lookup table which holds precomputed CRC8 results in order to generate a CRC8 byte for up to 64 bits of data per cycle. A description of this technique can be found in <a href="#4.-further-reading">Section 4</a> at the link &quot;CRC32 Byte by Byte&quot;. The internal state of the CRC8 generator should be reset to <code>0x00</code> at the start of every packet and the header and Type byte should be used to determine which bytes to run through the CRC8 generator. The resulting CRC8 byte should then be compared with the existing CRC8 byte generated by the transmitter. If the bytes are not the same, the type of the last transfer should be set to Error. The payload and header should then be sent to the payload manager.</p>
<h4 id="324-Payload-Manager">3.2.4 Payload Manager</h4>
<p>The payload manager checks incoming payloads and drops all Idle transfers. It does this by outputting an unbuffered valid signal and deasserting it every time there is an Idle transfer. The payload, header and valid signals are sent to the asynchronous FIFO.</p>
<h4 id="325-Asynchronous-FIFO">3.2.5 Asynchronous FIFO</h4>
<p>The asynchronous FIFO buffers all payload and header bits and allows the data to cross into the tx_usrclk2 domain from the rx_usrclk2 domain. The FIFO is a generic asynchronous FIFO with <code>almost_full</code>, <code>full</code>, <code>almost_empty</code> and <code>empty</code> warning signals. The <code>almost_full</code> and <code>almost_empty</code> signals are sent to the pause manager to generate the correct pause signal to send to the encoder as <code>inject_pause_in</code>. The <code>full</code> signal is unused but can be used for error reporting. The <code>empty</code> signal is inverted and sent to the decoder as <code>valid_in</code>. All signals are synchronized as necessary. The payload and header are used by the decoder.</p>
<h4 id="326-Pause-Manager">3.2.6 Pause Manager</h4>
<p>The pause manager constructs a single pause inject signal from multiple pause and unpause signals or pause inject signals or both. When the positive edge of a pause signal is seen this generates a positive edge on a pause inject signal. When the positive edge of an unpause signal is seen this generates a negative edge on a pause inject signal. When both are asserted in the same cycle the pause inject signal remains unchanged. All of the generated and input pause inject signals are OR'd together and the result is sent to the encoder as <code>inject_pause_in</code>.</p>
<h4 id="327-Decoder">3.2.7 Decoder</h4>
<p>The decoder takes the payload and header in the format described in <a href="##2.2-encoding-structure">Section 2.2</a> and generates a modified AXI4-Stream interface. All user-facing inputs and outputs are buffered. TREADY is omitted from the AXI4-Stream interface. When the decoder finds an Error or any invalid transfers in a packet, it sets TVALID low and sets <code>m_error</code> high for the remainder of the packet. The first valid transfer following the deassertion of <code>m_error</code> is the first transfer of the next packet. When the decoder finds a Pause packet it sets TVALID low and sets <code>m_error</code> low. It then asserts or deasserts <code>pause_out</code> which is sent to the RX interface as <code>m_pause</code> depending on D<sub>0</sub>-D<sub>3</sub>; if D<sub>0</sub>-D<sub>3</sub> != <code>0x00000000</code> the decoder asserts <code>pause_out</code>. If D<sub>0</sub>-D<sub>3</sub> = <code>0x00000000</code> the decoder deasserts <code>pause_out</code>. The decoder also outputs the Src of the Pause packet on <code>pause_src_out</code> which is sent to the RX interface as <code>m_pause_src</code>. The decoder should not find any Idle packets as they should have been removed by the payload manager but in the case that it does, the decoder sets TVALID low and sets <code>m_error</code> low.</p>
<h4 id="328-RX-Interface">3.2.8 RX Interface</h4>
<p>The user interface for RX consists of an AXI4-Stream interface with 64-bit TDATA, 8-bit TKEEP, 8-bit TUSER, 8-bit TDEST, 1-bit TLAST and 1-bit TVALID. As TREADY is omitted the RX cannot be backpressured. The RX also provides <code>m_error</code> to signal when it encounters invalid transfers. Clock and reset are provided by the transceiver.</p>
<table>
<thead>
<tr>
<th>Port</th>
<th style="text-align:right">Width</th>
<th style="text-align:center">Direction</th>
<th>Clock</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>tx_usrclk2_out</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>User clock from transceiver.</td>
</tr>
<tr>
<td>tx_reset_out</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>Reset from transceiver.</td>
</tr>
<tr>
<td>m_axis_tdata</td>
<td style="text-align:right">[63:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TDATA. Generated from payload.</td>
</tr>
<tr>
<td>m_axis_tkeep</td>
<td style="text-align:right">[7:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TKEEP. Generated from payload type.</td>
</tr>
<tr>
<td>m_axis_tuser</td>
<td style="text-align:right">[7:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TUSER. Generated from Src byte.</td>
</tr>
<tr>
<td>m_axis_tdest</td>
<td style="text-align:right">[7:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TDEST. Generated from Dst byte.</td>
</tr>
<tr>
<td>m_axis_tlast</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TLAST. generated from payload type.</td>
</tr>
<tr>
<td>m_axis_tvalid</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>AXI4-Stream TVALID. Used to signal valid.</td>
</tr>
<tr>
<td>m_error</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>Used to signal transfer error. The first valid transfer after an error transfer is the first transfer of a new packet.</td>
</tr>
<tr>
<td>m_pause</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>Signals whether a receiver on the network has requested a pause.</td>
</tr>
<tr>
<td>m_unpause</td>
<td style="text-align:right">[0:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>Signals whether a receiver on the network has requested an unpause.</td>
</tr>
<tr>
<td>m_pause_src</td>
<td style="text-align:right">[7:0]</td>
<td style="text-align:center">out</td>
<td>tx_usrclk2</td>
<td>Signals which receiver on the network has requested the pause or unpause.</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="4-Further-Reading">4. Further Reading</h2>
<table>
<thead>
<tr>
<th>Description</th>
<th>Link</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vivado HLS User Guide</td>
<td><a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_3/ug902-vivado-high-level-synthesis.pdf">https://www.xilinx.com/support/documentation/sw_manuals/xilinx2018_3/ug902-vivado-high-level-synthesis.pdf</a></td>
</tr>
<tr>
<td>Xilinx GTY User Guide</td>
<td><a href="https://www.xilinx.com/support/documentation/user_guides/ug578-ultrascale-gty-transceivers.pdf">https://www.xilinx.com/support/documentation/user_guides/ug578-ultrascale-gty-transceivers.pdf</a></td>
</tr>
<tr>
<td>Xilinx Transceiver Wizard Product Guide</td>
<td><a href="https://www.xilinx.com/support/documentation/ip_documentation/gtwizard_ultrascale/v1_7/pg182-gtwizard-ultrascale.pdf">https://www.xilinx.com/support/documentation/ip_documentation/gtwizard_ultrascale/v1_7/pg182-gtwizard-ultrascale.pdf</a></td>
</tr>
<tr>
<td>IEEE 802.3 Clause 49 64b66b Encoding</td>
<td><a href="http://www.ieee802.org/3/ap/public/sep05/szczepanek_02_0905.pdf">http://www.ieee802.org/3/ap/public/sep05/szczepanek_02_0905.pdf</a></td>
</tr>
<tr>
<td>AXI4-Stream Specification</td>
<td><a href="http://www.mrc.uidaho.edu/mrc/people/jff/EO_440/Handouts/AMBA%20Protocols/AXI-Stream/IHI0051A_amba4_axi4_stream_v1_0_protocol_spec.pdf">http://www.mrc.uidaho.edu/mrc/people/jff/EO_440/Handouts/AMBA Protocols/AXI-Stream/IHI0051A_amba4_axi4_stream_v1_0_protocol_spec.pdf</a></td>
</tr>
<tr>
<td>Asynchronous FIFOs</td>
<td><a href="http://www.asic-world.com/examples/verilog/asyn_fifo.html">http://www.asic-world.com/examples/verilog/asyn_fifo.html</a></td>
</tr>
<tr>
<td>CRC32 Byte by Byte</td>
<td><a href="http://www.sunshine2k.de/articles/coding/crc/understanding_crc.html#ch44">http://www.sunshine2k.de/articles/coding/crc/understanding_crc.html#ch44</a></td>
</tr>
</tbody>
</table>
<hr>

    </body>
    </html>